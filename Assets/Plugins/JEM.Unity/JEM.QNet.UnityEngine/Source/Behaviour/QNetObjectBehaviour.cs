//
// QNet for Unity Engine - Just Enough Methods Library Source
//
// Copyright (c) 2017-2019 ADAM MAJCHEREK ALL RIGHTS RESERVED
//

using JEM.Core.Debugging;
using JEM.QNet.Messages;
using JEM.QNet.UnityEngine.Extensions;
using JEM.QNet.UnityEngine.Game;
using JEM.QNet.UnityEngine.Messages;
using JetBrains.Annotations;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using UnityEngine;
using Random = UnityEngine.Random;

namespace JEM.QNet.UnityEngine.Behaviour
{
    /// <inheritdoc />
    /// <summary>
    ///     QNet object behaviour script base.
    /// </summary>
    [SuppressMessage("ReSharper", "InconsistentNaming")]
    public abstract class QNetObjectBehaviour : MonoBehaviour
    {
        [SerializeField]
        [HideInInspector]
        private short objIdentity;

        /// <summary>
        ///     Defines whether this object is correctly spawned.
        ///     In most cases it's all ways true.
        /// </summary>
        public bool Spawned { get; private set; }

        /// <summary>
        ///     Identity of QNetObject generated by server while spawning.
        /// </summary>
        public short ObjectIdentity => objIdentity;

        /// <summary>
        ///     Defines whether this object is predefined.
        /// </summary>
        public bool IsPredefined { get; private set; }

        /// <summary>
        ///     Prefab of this QNetObject.
        /// </summary>
        public QNetObjectPrefab Prefab { get; private set; }

        /// <summary>
        ///     Identity of owner(player) of this object.
        ///     If set to zero, there is no owner and as default, this object belongs only to server.
        /// </summary>
        public short OwnerIdentity { get; private set; }

        /// <summary>
        ///     QNetConnection of owner.
        /// </summary>
        public QNetConnection OwnerConnection => QNetManager.Server.GetConnection(OwnerIdentity);

        /// <summary>
        ///     Defines whether local player is an owner of this object.
        /// </summary>
        public bool IsOwner { get; private set; }

        /// <summary>
        ///     Time the last entity snapshot was sent.
        /// </summary>
        public float LastSnapshotTime { get; set; }

        /// <summary>
        ///     Defines whether local server is an owner of this object.
        ///     Non-server peers will always have this value false.
        /// </summary>
        public bool IsOwnedByServer =>
            IsServer && (OwnerIdentity == 0 || IsHost && OwnerIdentity == QNetManager.Client.ConnectionIdentity);

        /// <summary>
        ///     Defines whether this object is running on client.
        /// </summary>
        public bool IsClient => isClient;

        /// <summary>
        ///     Defines whether this object is running on server.
        /// </summary>
        public bool IsServer => isServer;

        /// <summary>
        ///     Defines whether this object is running on host.
        /// </summary>
        public bool IsHost => isHost;

        /// <summary>
        ///     Defines whether any network peer is running. If so, object can work and be updated.
        /// </summary>
        public bool IsRunning => isRunning;

        private void Start()
        {
            if (!Spawned)
            {
                // don't print log because of new object predefine feature
                // JEMLogger.Log("QNetObjectBehaviour based script is on object that was incorrectly spawned or is predefined on scene. This is not supported by QNet. To spawn QNet objects, please use QNetObjectBehaviour.Spawn on server.");
                gameObject.SetActive(false);
                IsPredefined = true;
                _predefinedBehaviours.Add(this);

                // rebuild array
                PredefinedBehaviours = _predefinedBehaviours.ToArray();
                return;
            }

            if (!IsRunning && !QNetGameInitializer.ServerIsInitializing)
            {
                JEMLogger.Log("QNetObjectBehaviour has been spawned but somehow there is not peer running.");
                gameObject.SetActive(false);
                return;
            }

            InternalStart();
        }

        /// <summary>
        ///     Checks if given connection owns this object.
        /// </summary>
        public bool CheckConnectionOwner(QNetConnection connection)
        {
            if (QNetManager.IsHostActive && (OwnerIdentity == 0 ||
                                             connection.ConnectionIdentity == QNetManager.Client.ConnectionIdentity ||
                                             connection.ConnectionIdentity == 0))
                return true;
            return OwnerIdentity == connection.ConnectionIdentity;
        }

        /// <summary>
        ///     Updates identity of object.
        /// </summary>
        public void UpdateIdentity(short objectIdentity, short ownerIdentity)
        {
            objIdentity = objectIdentity;
            OwnerIdentity = ownerIdentity;
        }

        /// <summary>
        ///     Start method.
        /// </summary>
        protected virtual void InternalStart()
        {
            // start :D
        }

        /// <summary>
        ///     On network active method.
        /// </summary>
        public virtual void OnNetworkActive()
        {
            // do something when network has has been activated
            // on client this method is executed right after the OnInternalSpawned
        }

        /// <summary>
        ///     On spawned method.
        /// </summary>
        public virtual void OnInternalSpawned()
        {
            // do something on object spawn, for ex. use isOwner to initialize owner's stuff
        }

        /// <summary>
        ///     On destroy method.
        /// </summary>
        public virtual void OnInternalDestroy()
        {
            // do something on object destroy, for ex. destroy local object's that this QNetObject spawn.
        }

        /// <summary/>
        public virtual void OnBeginSimulate() { }

        /// <summary>
        ///     Simulate the object!
        /// </summary>
        public virtual void Simulate() { }

        /// <summary/>
        public virtual void OnFinishSimulate() { }

        /// <summary>
        ///     Send snapshot of object!
        /// </summary>
        public virtual void SendSnapshot() { }

        /// <summary>
        ///     Calls server object state serializer, and sends it to all clients.
        /// </summary>
        public void SerializeAndSendServerState()
        {
            if (!IsServer) throw new InvalidOperationException("Only server can send current state of object.");

            var writer = QNetManager.Server.GenerateOutgoingMessage(QNetUnityLocalHeader.OBJECT_STATE);
            writer.WriteInt16(ObjectIdentity);
            SerializeServerObjectState(writer);
            QNetManager.Server.SendToAll(QNetUnityLocalChannel.OBJECT_QUERY, QNetMessageMethod.ReliableOrdered, writer);
        }

        /// <summary>
        ///     Serializes current state of object from server side.
        ///     In most cases used to update current state of object on all clients.
        /// </summary>
        public virtual void SerializeServerObjectState(QNetMessageWriter writer)
        {
            // serialize some cool data like for example: current animations or currently used tools by character
        }

        /// <summary>
        ///     De-serialize object state send by server.
        /// </summary>
        public virtual void DeSerializeServerState(QNetMessageReader reader)
        {
            // de-serialize state send by server!
        }

        /// <summary>
        ///     Spawns new object in world by QNet.
        /// </summary>
        /// <param name="prefab">Prefab of object to spawn.</param>
        /// <param name="position">Position of object to spawn.</param>
        /// <param name="rotation">Rotation of object to spawn.</param>
        /// \
        /// <param name="skipObjectBroadcast">If true, system will skip SendObjectToAllConnection method.</param>
        public static QNetObjectBehaviour Spawn(QNetObjectPrefab prefab, Vector3 position, Quaternion rotation,
            bool skipObjectBroadcast = false)
        {
            return SpawnWithOwner(prefab, position, rotation, 0, skipObjectBroadcast);
        }

        /// <summary>
        ///     Spawns new object in world by QNet.
        /// </summary>
        /// <param name="prefab">Prefab of object to spawn.</param>
        /// <param name="position">Position of object to spawn.</param>
        /// <param name="rotation">Rotation of object to spawn.</param>
        /// <param name="ownerConnection">Connection of owner.</param>
        /// <param name="skipObjectBroadcast">If true, system will skip SendObjectToAllConnection method.</param>
        public static QNetObjectBehaviour SpawnWithOwner(QNetObjectPrefab prefab, Vector3 position, Quaternion rotation,
            QNetConnection ownerConnection, bool skipObjectBroadcast = false)
        {
            return SpawnWithOwner(prefab, position, rotation, ownerConnection.ConnectionIdentity, skipObjectBroadcast);
        }

        /// <summary>
        ///     Spawns new object in world by QNet.
        /// </summary>
        /// <param name="prefab">Prefab of object to spawn.</param>
        /// <param name="position">Position of object to spawn.</param>
        /// <param name="rotation">Rotation of object to spawn.</param>
        /// <param name="ownerIdentity">Identity of owner.</param>
        /// <param name="skipObjectBroadcast">If true, system will skip SendObjectToAllConnection method.</param>
        public static QNetObjectBehaviour SpawnWithOwner(QNetObjectPrefab prefab, Vector3 position, Quaternion rotation,
            short ownerIdentity, bool skipObjectBroadcast = false)
        {
            if (!QNetManager.IsServerActive)
                throw new InvalidOperationException("You can only spawn QNetObjects from server.");

            // then spawn local instance of object to make sure that everything is ok.
            var behaviour = InternalSpawn(GenerateObjectIdentity(), prefab, position, rotation, ownerIdentity);
            if (behaviour == null)
                return null;

            if (!skipObjectBroadcast) QNetServerObjects.SendObjectToAllConnections(behaviour);

            return behaviour;
        }

        /// <summary>
        ///     Spawns new object in local world by QNet.
        /// </summary>
        /// <param name="identity">Identity of this object.</param>
        /// <param name="prefab">Prefab of object to spawn.</param>
        /// <param name="position">Position of object to spawn.</param>
        /// <param name="rotation">Rotation of object to spawn.</param>
        /// <param name="ownerIdentity">Identity of owner.</param>
        public static QNetObjectBehaviour InternalSpawn(short identity, [NotNull] QNetObjectPrefab prefab,
            Vector3 position,
            Quaternion rotation, short ownerIdentity)
        {
            if (prefab == null) throw new ArgumentNullException(nameof(prefab));
            if (prefab.Prefab == null) throw new ArgumentNullException(nameof(prefab.Prefab));
            // fist, check if given prefab is added to QNetDatabase
            if (QNetManager.Database.GetPrefab(prefab.PrefabIdentity) == null)
            {
                JEMLogger.LogError(
                    $"System is trying to spawn QNetObject that isn't registered in database ({prefab.PrefabIdentity}).");
                return null;
            }

            var existedObject = GetSpawnedObject(identity);
            if (existedObject != null)
            {
                if (QNetManager.IsHostActive) return existedObject;

                JEMLogger.LogError(
                    $"System is trying to spawn QNetObject of identity that already exists. ({identity})");
                return null;
            }

            // now, spawn this bad boy
            var instance = Instantiate(prefab.Prefab.gameObject, position, rotation);
            var behaviour = instance.GetComponent<QNetObjectBehaviour>();
            if (behaviour == null)
                throw new InvalidOperationException(
                    "System is unable to resolve QNetObjectBehaviour from spawned object.");
            behaviour.Spawned = true;
            behaviour.objIdentity = identity;
            behaviour.OwnerIdentity = ownerIdentity;
            if (QNetManager.IsServerActive &&
                (ownerIdentity == 0 || ownerIdentity == (QNetManager.Client?.ConnectionIdentity ?? 0)))
                behaviour.IsOwner = true;
            else
                behaviour.IsOwner = QNetManager.Client != null && ownerIdentity != 0 &&
                                    ownerIdentity == QNetManager.Client.ConnectionIdentity;

            behaviour.Prefab = prefab;
            behaviour.OnInternalSpawned();

            _spawnedBehaviours.Add(behaviour);
            // rebuild array
            SpawnedBehaviours = _spawnedBehaviours.ToArray();
            return behaviour;
        }

        /// <summary>
        ///     Destroys given object.
        /// </summary>
        /// <param name="obj">Object to destroy.</param>
        public static void Destroy(QNetObjectBehaviour obj)
        {
            if (obj == null) return;
            if (!QNetManager.IsServerActive)
                throw new InvalidOperationException("You can only destroy QNetObjects from server.");

            // send destroy message to all connections
            QNetServerObjects.DestroyObjectOnAllConnections(obj);

            // and then destroy this object on local machine
            InternalDestroy(obj);
        }

        internal static IEnumerator DestroyAll()
        {
            var index = SpawnedBehaviours.Length;
            while (SpawnedBehaviours.Length > 0 && index > 0)
            {
                InternalDestroy(SpawnedBehaviours[0]);
                index--;
                yield return new WaitForEndOfFrame();
            }
        }

        /// <summary>
        ///     Destroy given object in local world of QNet.
        /// </summary>
        /// <param name="obj">Object to destroy.</param>
        public static void InternalDestroy([NotNull] QNetObjectBehaviour obj)
        {
            if (obj == null) return;
            obj.Spawned = false;
            obj.OnInternalDestroy();
            obj.OwnerIdentity = 0;

            if (_spawnedBehaviours.Contains(obj))
            {
                Destroy(obj.gameObject);
                _spawnedBehaviours.Remove(obj);

                // rebuild array
                SpawnedBehaviours = _spawnedBehaviours.ToArray();
            }
            else if (_predefinedBehaviours.Contains(obj))
            {
                obj.gameObject.SetActive(false);
                _predefinedBehaviours.Remove(obj);

                // rebuild array
                PredefinedBehaviours = _predefinedBehaviours.ToArray();
            }
            else
            {
                Destroy(obj.gameObject);
                JEMLogger.LogError("InvalidQNetObject to destroy");
            }
        }

        /// <summary>
        ///     Gets QNetObject by given identity.
        /// </summary>
        public static T GetObject<T>(short objectIdentity) where T : QNetObjectBehaviour
        {
            var obj = GetSpawnedObject<T>(objectIdentity);
            if (obj == null || obj.Equals(default(T)))
                obj = GetPredefinedObject<T>(objectIdentity);
            return obj;
        }

        /// <summary>
        ///     Gets QNetObject by given identity.
        /// </summary>
        public static QNetObjectBehaviour GetObject(short objectIdentity)
        {
            var obj = GetSpawnedObject(objectIdentity);
            if (obj == null)
                obj = GetPredefinedObject(objectIdentity);
            return obj;
        }

        /// <summary>
        ///     Gets spawned QNetObject by given identity.
        /// </summary>
        public static T GetSpawnedObject<T>(short objectIdentity) where T : QNetObjectBehaviour
        {
            return (from obj in SpawnedBehaviours
                where obj != null
                let type = obj.GetComponent<T>()
                where obj.ObjectIdentity == objectIdentity && type != null
                select type).FirstOrDefault();
        }

        /// <summary>
        ///     Gets spawned QNetObject by given identity.
        /// </summary>
        public static QNetObjectBehaviour GetSpawnedObject(short objectIdentity)
        {
            return SpawnedBehaviours.Where(obj => obj != null)
                .FirstOrDefault(obj => obj.ObjectIdentity == objectIdentity);
        }

        /// <summary>
        ///     Gets predefined QNetObject by given identity.
        /// </summary>
        public static T GetPredefinedObject<T>(short objectIdentity) where T : QNetObjectBehaviour
        {
            return (from obj in PredefinedBehaviours
                where obj != null
                let type = obj.GetComponent<T>()
                where obj.ObjectIdentity == objectIdentity && type != null
                select type).FirstOrDefault();
        }

        /// <summary>
        ///     Gets predefined QNetObject by given identity.
        /// </summary>
        public static QNetObjectBehaviour GetPredefinedObject(short objectIdentity)
        {
            return PredefinedBehaviours.Where(obj => obj != null)
                .FirstOrDefault(obj => obj.ObjectIdentity == objectIdentity);
        }

        /// <summary>
        ///     Generates new object identity.
        /// </summary>
        /// <returns></returns>
        public static short GenerateObjectIdentity()
        {
            // first, generate new object identity
            var identity = (short) Random.Range(short.MinValue, short.MaxValue);
            while (GetObject(identity) != null)
                identity = (short) Random.Range(short.MinValue, short.MaxValue);
            return identity;
        }

        /// <summary>
        ///     Clears list of behaviours.
        /// </summary>
        public static void ClearBehaviours()
        {
            _spawnedBehaviours.Clear();
            _predefinedBehaviours.Clear();

            // rebuild array
            SpawnedBehaviours = new QNetObjectBehaviour[0];
            PredefinedBehaviours = new QNetObjectBehaviour[0];
        }

        /// <summary>
        ///     Defines whether this object is running on client.
        /// </summary>
        public static bool isClient => QNetManager.IsClientActive || QNetGameInitializer.HostIsInitializing;

        /// <summary>
        ///     Defines whether this object is running on server.
        /// </summary>
        public static bool isServer => QNetManager.IsServerActive || QNetGameInitializer.ServerIsInitializing;

        /// <summary>
        ///     Defines whether this object is running on host.
        /// </summary>
        public static bool isHost => QNetManager.IsHostActive || QNetGameInitializer.HostIsInitializing;

        /// <summary>
        ///     Defines whether any network peer is running. If so, object can work and be updated.
        /// </summary>
        public static bool isRunning => isClient || isServer || isHost;

        /// <summary>
        ///     Spawned QNetObjectBehaviours on local machine.
        /// </summary>
        public static QNetObjectBehaviour[] SpawnedBehaviours { get; private set; } = new QNetObjectBehaviour[0];
        private static List<QNetObjectBehaviour> _spawnedBehaviours { get; } = new List<QNetObjectBehaviour>();

        /// <summary>
        ///     Predefined QNetObjectBehaviours on local machine.
        /// </summary>
        public static QNetObjectBehaviour[] PredefinedBehaviours { get; private set; } = new QNetObjectBehaviour[0];
        private static List<QNetObjectBehaviour> _predefinedBehaviours { get; } = new List<QNetObjectBehaviour>();
    }
}